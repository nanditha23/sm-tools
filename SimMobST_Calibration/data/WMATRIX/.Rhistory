temp <- subset(TripChain_raw, select=c(trip_id, person_id, trip_start_time,
subtrip_origin_id, subtrip_destination_id,
sequence_num, travel_mode))
# Only car and taxi to be considered
TripChain_anal <- subset(temp , travel_mode=='Car' | travel_mode=='Taxi')
# 2.2 TAZ data
TAZ_raw <- as.data.table(fread('node_to_zone.csv'))
## 3. Data assimilation of TripChain & TAZ ==> Table 1 & 2
# 3.1 Table 1 (Refefence table): OD pair
ODpair_temp <- subset(TripChain_anal, select=c(subtrip_origin_id, subtrip_destination_id))
ODpair <- unique(ODpair_temp)
NtoZ <- function(node){
zone <- TAZ_raw$zone_id[which(TAZ_raw$id==node)]
return(zone)
}
# Generation of OD pair table * NEED TO BE IMPROVED, TAKES TOO MUCH TIME
i<-1
zone <- c(NtoZ(ODpair[i,]$subtrip_origin_id), NtoZ(ODpair[i,]$subtrip_destination_id))
for (i in 2:dim(ODpair)[1]){
temp <- c(NtoZ(ODpair[i,]$subtrip_origin_id), NtoZ(ODpair[i,]$subtrip_destination_id))
zone <- rbind(zone, temp)
}
colnames(zone) <- c('zone_o', 'zone_d')
index <- c(1:dim(ODpair)[1])
ODpair <- cbind(index, ODpair, zone)
# 3.2 Table 2 (Data table): OD data
# Starting Time
# Converting time unit into 'sec'
time <- strsplit(TripChain_anal$trip_start_time, ":")
TimeConverter <- function(time){
time <- as.numeric(time)
time[1]*3600+time[2]*60+time[3]
}
startingtime <- sapply(time, TimeConverter)
TripChain_anal$trip_start_time <- startingtime # Inserting changed time format
# Time interval
no_interval_od = (end-start)/interval_od; # Classify simulation time into each time interval
t_od <- array(0, dim=no_interval_od);
t_od[1] = start;
for (i in 2:no_interval_od){
t_od[i] = t_od[i-1] + interval_od;
}
# Vehicle count through individual allocation for each time interval and OD pairs
uni_tinterval <- t_od
#1 Based on time interval
# OD index to TripChain
ODpair_temp <- ODpair
code <- paste(TripChain_anal$subtrip_origin_id,TripChain_anal$subtrip_destination_id, sep=" ")
TripChain_anal <- cbind(TripChain_anal, code)
code <- paste(ODpair$subtrip_origin_id,ODpair$subtrip_destination_id, sep=" ")
ODpair_temp <- cbind(ODpair_temp, code)
#index
index<-0; j <- which(TripChain_anal$code==ODpair_temp$code[i<-1])
index[j] <- ODpair_temp$index[i]
for (i in 2:dim(ODpair_temp)[1]){
j <- which(TripChain_anal$code==ODpair_temp$code[i])
index[j] <- ODpair_temp$index[i]
}
TripChain_anal <- cbind(TripChain_anal, index)
# Split TripChain into each time interval
for (i in 1:length(uni_tinterval)){
if (i==length(uni_tinterval)){
ad <- which(TripChain_anal$trip_start_time>uni_tinterval[i] & TripChain_anal$trip_start_time<=(uni_tinterval[i]+900))
ti <- as.data.table(rep(uni_tinterval[i], time=length(ad))); colnames(ti) <- c('ti')
sl <- cbind(TripChain_anal[ad], ti)
assign(paste("sl", i, sep = "."), sl)
} else {
ad <- which(TripChain_anal$trip_start_time>=uni_tinterval[i] & TripChain_anal$trip_start_time<uni_tinterval[i+1])
ti <- as.data.table(rep(uni_tinterval[i], time=length(ad))); colnames(ti) <- c('ti')
sl <- cbind(TripChain_anal[ad], ti)
assign(paste("sl", i, sep = "."), sl)
}
}
#2 Based on OD pair
myList <- ls(pattern = "sl.")
for (i in 1:length(myList)){
myTemp <- get(myList[i])
myTable <- as.data.frame(table(myTemp$index))
colnames(myTable) <-c('index_a', 'count')
ODpair <- as.data.frame(ODpair); colnames(ODpair) <- c('index_a', colnames(ODpair)[2:5])
# should we? ODpair$index_a <- as.numeric(ODpair$index_a) myTable$index_a <- as.numeric(myTable$index_a)
if (i==1){
ODdata <- merge(ODpair, myTable, by='index_a', all=TRUE)
} else {
temp <- merge(ODpair, myTable, by='index_a', all=TRUE)
ODdata <- rbind(ODdata, temp)
}
}
#3 NA count to be 0
ODdata[which(is.na(ODdata$count)),]$count <- 0
#4 Add Time Interval
time_interval <- as.data.table(rep(uni_tinterval, each=dim(ODpair)[1])); colnames(time_interval) <- c('time_interval')
ODdata <- cbind(ODdata, time_interval)
# -> Dimension of ODdata is (44,077*4=176,308). So, Zone data
# 3.3 Table 3 (Data table): Zone data
zonecode <- as.data.table(paste(ODdata$zone_o, ODdata$zone_d, sep=" ")); colnames(zonecode) <- c("zonecode")
ODdata_forzone <- ODdata;
ODdata_forzone <- cbind(ODdata_forzone, zonecode)
Zonepair <- as.data.table(unique(ODdata_forzone$zonecode)); colnames(Zonepair) <- c("zonecode")
temp <- separate(Zonepair, col=zonecode, into=c("zone_o", "zone_d"), sep=" ")
index_forzone <- c(1:dim(Zonepair)[1])
Zonepair <- cbind(Zonepair, temp, index_forzone)
for (i in 1:length(uni_tinterval)){
temp1 <- subset(ODdata_forzone, subset=(time_interval==uni_tinterval[i]))
myTable_forzone <- as.data.frame(table(temp1$zonecode)); colnames(myTable_forzone) <- c("zonecode", "count")
if (i==1){
Zonedata <- merge(Zonepair, myTable_forzone, by='zonecode', all=TRUE)
Zonedata <- Zonedata[order(Zonedata$index_forzone),] # Ordering
Zonedata <- cbind(Zonedata, rep(uni_tinterval[i], dim(Zonedata)[1]))
} else {
temp2 <- merge(Zonepair, myTable_forzone, by='zonecode', all=TRUE)
temp2 <- temp2[order(temp2$index_forzone),] # Ordering
temp2 <- cbind(temp2, rep(uni_tinterval[i], dim(temp2)[1]))
Zonedata <- rbind(Zonedata, temp2)
}
}
colnames(Zonedata) <- c(colnames(Zonedata)[1:(dim(Zonedata)[2]-1)], "time_interval")
# -> Dimension of ODdata is (37,351*4=149,404). 15% reduced from size of OD data.
# 3.4 Table 4 (Calibration table): Theta
# OD theta
theta_od = subset(ODdata, select=c('count'))
# Zone theta
theta_zone = subset(Zonedata, select=c('count'))
# 4. Saving
write.csv(theta_od, file='odtheta.csv')
write.csv(theta_zone, file='zonetheta.csv')
F_end <- proc.time()
F_computationtime <- (F_end-F_start)[3] #unit: sec
write.csv(F_computationtime, file='F_computationtime.csv')
}
Ffunction(15, 10, 11)
workpath <- c('/home/simon/Copy/SimMobility/Calibration Program/SimMob_ST_Calibration_SGE - Simon/Expr/')
cd (workpath)
system(cd(workpath))
workpath <- c('/home/simon/Copy/SimMobility/Calibration Program/SimMob_ST_Calibration_SGE - Simon/Expr/')
setwd(workpath)
getwd()
setwd(workpath)
workpath <- c('/home/simon/Copy/SimMobility/Calibration Program/SimMob_ST_Calibration_SGE - Simon/Expr/')
setwd(workpath)
interval_od_min <- 15; interval_sensor <- 15; no_sensor <- 650;
start_hr <- 7.5; end_hr <- 8.5 # Previously, start = 10; end = 11;
interval_od_min <- 15; interval_sensor <- 15; no_sensor <- 650;
start <- start_hr*60*60 # 10AM (unit: sec)
end <- end_hr*60*60 # 11AM (unit: sec)
interval_od <- interval_od_min*60 # time interval: 15min -> 900sec
interval_sensor <-  interval_sensor_min*60  # time interval: 5min -> 900sec
no_sensor <-  no_sensor # To be defined
start
end
no_interval_od
no_interval_od = (end-start)/interval_od; # Classify simulation time into each time interval
no_interval_sensor = (end-start)/interval_sensor;
no_interval_sensor
no_interval_od
setwd("/home/simon/Copy/SimMobility/Calibration Program/SimMob_ST_Calibration_SGE - Simon/data/WMATRIX")
list.files()
ass
ass <- read.table("assignment_matrix.csv", sep=" ") #st
odpair <- read.table("baseFile.csv", sep=",")
odpair
head(odpair)
start_hr <- 10; end_hr <- 11 # Previously, start = 10; end = 11;
interval_od_min <- 15; interval_sensor <- 15; no_sensor <- 650;
setwd('/home/simon/Copy/SimMobility/Calibration Program/SimMob_ST_Calibration_SGE - Simon/data/TripChain')
list.files()
#install.packages("data.table")
library("data.table") # For "data.table" and "fread"
#install.packages("tidyr")
library("tidyr") # For "separate"
# Input: as input parameter
start <- start_hr*60*60 # 10AM (unit: sec)
end <- end_hr*60*60 # 11AM (unit: sec)
interval_od <- interval_od_min*60 # time interval: 15min -> 900sec
TripChain_raw <- as.data.table(fread('TripChain.csv', sep = ';'))
temp <- subset(TripChain_raw, select=c(trip_id, person_id, trip_start_time,
subtrip_origin_id, subtrip_destination_id,
sequence_num, travel_mode))
# Only car and taxi to be considered
TripChain_anal <- subset(temp , travel_mode=='Car' | travel_mode=='Taxi')
TAZ_raw <- as.data.table(fread('node_to_zone.csv'))
start_hr <- 10; end_hr <- 11 # Previously, start = 10; end = 11;
interval_od_min <- 15; interval_sensor <- 15; no_sensor <- 650;
F_start <- proc.time()
## 1. Environmental setting
# Set working directory
setwd('/home/simon/Copy/SimMobility/Calibration Program/SimMob_ST_Calibration_SGE - Simon/data/TripChain')
list.files()
# Instal packages
#install.packages("data.table")
library("data.table") # For "data.table" and "fread"
#install.packages("tidyr")
library("tidyr") # For "separate"
# Input: as input parameter
start <- start_hr*60*60 # 10AM (unit: sec)
end <- end_hr*60*60 # 11AM (unit: sec)
interval_od <- interval_od_min*60 # time interval: 15min -> 900sec
## 2. Data import
# 2.1 TripChain data
TripChain_raw <- as.data.table(fread('TripChain.csv', sep = ';'))
temp <- subset(TripChain_raw, select=c(trip_id, person_id, trip_start_time,
subtrip_origin_id, subtrip_destination_id,
sequence_num, travel_mode))
# Only car and taxi to be considered
TripChain_anal <- subset(temp , travel_mode=='Car' | travel_mode=='Taxi')
# 2.2 TAZ data
TAZ_raw <- as.data.table(fread('node_to_zone.csv'))
## 3. Data assimilation of TripChain & TAZ ==> Table 1 & 2
# 3.1 Table 1 (Refefence table): OD pair
ODpair_temp <- subset(TripChain_anal, select=c(subtrip_origin_id, subtrip_destination_id))
ODpair <- unique(ODpair_temp)
NtoZ <- function(node){
zone <- TAZ_raw$zone_id[which(TAZ_raw$id==node)]
return(zone)
}
# Generation of OD pair table * NEED TO BE IMPROVED, TAKES TOO MUCH TIME
i<-1
zone <- c(NtoZ(ODpair[i,]$subtrip_origin_id), NtoZ(ODpair[i,]$subtrip_destination_id))
for (i in 2:dim(ODpair)[1]){
temp <- c(NtoZ(ODpair[i,]$subtrip_origin_id), NtoZ(ODpair[i,]$subtrip_destination_id))
zone <- rbind(zone, temp)
}
colnames(zone) <- c('zone_o', 'zone_d')
index <- c(1:dim(ODpair)[1])
ODpair <- cbind(index, ODpair, zone)
dim(ODpair)
head(zone)
ODpair
# 3.2 Table 2 (Data table): OD data
# Starting Time
# Converting time unit into 'sec'
time <- strsplit(TripChain_anal$trip_start_time, ":")
TimeConverter <- function(time){
time <- as.numeric(time)
time[1]*3600+time[2]*60+time[3]
}
startingtime <- sapply(time, TimeConverter)
TripChain_anal$trip_start_time <- startingtime # Inserting changed time format
# Time interval
no_interval_od = (end-start)/interval_od; # Classify simulation time into each time interval
t_od <- array(0, dim=no_interval_od);
t_od[1] = start;
for (i in 2:no_interval_od){
t_od[i] = t_od[i-1] + interval_od;
}
# Vehicle count through individual allocation for each time interval and OD pairs
uni_tinterval <- t_od
#1 Based on time interval
# OD index to TripChain
ODpair_temp <- ODpair
code <- paste(TripChain_anal$subtrip_origin_id,TripChain_anal$subtrip_destination_id, sep=" ")
TripChain_anal <- cbind(TripChain_anal, code)
code <- paste(ODpair$subtrip_origin_id,ODpair$subtrip_destination_id, sep=" ")
ODpair_temp <- cbind(ODpair_temp, code)
#index
index<-0; j <- which(TripChain_anal$code==ODpair_temp$code[i<-1])
index[j] <- ODpair_temp$index[i]
for (i in 2:dim(ODpair_temp)[1]){
j <- which(TripChain_anal$code==ODpair_temp$code[i])
index[j] <- ODpair_temp$index[i]
}
TripChain_anal <- cbind(TripChain_anal, index)
# Split TripChain into each time interval
for (i in 1:length(uni_tinterval)){
if (i==length(uni_tinterval)){
ad <- which(TripChain_anal$trip_start_time>uni_tinterval[i] & TripChain_anal$trip_start_time<=(uni_tinterval[i]+900))
ti <- as.data.table(rep(uni_tinterval[i], time=length(ad))); colnames(ti) <- c('ti')
sl <- cbind(TripChain_anal[ad], ti)
assign(paste("sl", i, sep = "."), sl)
} else {
ad <- which(TripChain_anal$trip_start_time>=uni_tinterval[i] & TripChain_anal$trip_start_time<uni_tinterval[i+1])
ti <- as.data.table(rep(uni_tinterval[i], time=length(ad))); colnames(ti) <- c('ti')
sl <- cbind(TripChain_anal[ad], ti)
assign(paste("sl", i, sep = "."), sl)
}
}
#2 Based on OD pair
myList <- ls(pattern = "sl.")
for (i in 1:length(myList)){
myTemp <- get(myList[i])
myTable <- as.data.frame(table(myTemp$index))
colnames(myTable) <-c('index_a', 'count')
ODpair <- as.data.frame(ODpair); colnames(ODpair) <- c('index_a', colnames(ODpair)[2:5])
# should we? ODpair$index_a <- as.numeric(ODpair$index_a) myTable$index_a <- as.numeric(myTable$index_a)
if (i==1){
ODdata <- merge(ODpair, myTable, by='index_a', all=TRUE)
} else {
temp <- merge(ODpair, myTable, by='index_a', all=TRUE)
ODdata <- rbind(ODdata, temp)
}
}
#3 NA count to be 0
ODdata[which(is.na(ODdata$count)),]$count <- 0
#4 Add Time Interval
time_interval <- as.data.table(rep(uni_tinterval, each=dim(ODpair)[1])); colnames(time_interval) <- c('time_interval')
ODdata <- cbind(ODdata, time_interval)
# -> Dimension of ODdata is (44,077*4=176,308). So, Zone data
# 3.3 Table 3 (Data table): Zone data
zonecode <- as.data.table(paste(ODdata$zone_o, ODdata$zone_d, sep=" ")); colnames(zonecode) <- c("zonecode")
ODdata_forzone <- ODdata;
ODdata_forzone <- cbind(ODdata_forzone, zonecode)
Zonepair <- as.data.table(unique(ODdata_forzone$zonecode)); colnames(Zonepair) <- c("zonecode")
temp <- separate(Zonepair, col=zonecode, into=c("zone_o", "zone_d"), sep=" ")
index_forzone <- c(1:dim(Zonepair)[1])
Zonepair <- cbind(Zonepair, temp, index_forzone)
for (i in 1:length(uni_tinterval)){
temp1 <- subset(ODdata_forzone, subset=(time_interval==uni_tinterval[i]))
myTable_forzone <- as.data.frame(table(temp1$zonecode)); colnames(myTable_forzone) <- c("zonecode", "count")
if (i==1){
Zonedata <- merge(Zonepair, myTable_forzone, by='zonecode', all=TRUE)
Zonedata <- Zonedata[order(Zonedata$index_forzone),] # Ordering
Zonedata <- cbind(Zonedata, rep(uni_tinterval[i], dim(Zonedata)[1]))
} else {
temp2 <- merge(Zonepair, myTable_forzone, by='zonecode', all=TRUE)
temp2 <- temp2[order(temp2$index_forzone),] # Ordering
temp2 <- cbind(temp2, rep(uni_tinterval[i], dim(temp2)[1]))
Zonedata <- rbind(Zonedata, temp2)
}
}
colnames(Zonedata) <- c(colnames(Zonedata)[1:(dim(Zonedata)[2]-1)], "time_interval")
# -> Dimension of ODdata is (37,351*4=149,404). 15% reduced from size of OD data.
# 3.4 Table 4 (Calibration table): Theta
# OD theta
theta_od = subset(ODdata, select=c('count'))
# Zone theta
theta_zone = subset(Zonedata, select=c('count'))
dim(ODdata)
dim(ODpair)
head(ODpair)
tail(ODpair)
tail(Zonedata)
tail(Zonepair)
dim(Zonepair)
dim(Zonedata)
dim(Zonedata)*4
dim(Zonepair)*4
Zonepair
theta_zone
# 4. Saving
write.csv(ODdata, file='ODdata.csv')
write.csv(Zonedata, file='Zonedata.csv')
write.csv(ODpair, file='ODpair.csv')
write.csv(Zonepair, file='Zonepair.csv')
odpair
odpair <- read.table("baseFile.csv", sep=",")
start_hr <- 7.5; end_hr <- 8.5 # Previously, start = 10; end = 11;
interval_od_min <- 15; interval_sensor <- 15; no_sensor <- 650;
start_hr <- 7.5; end_hr <- 8.5 # Previously, start = 10; end = 11;
interval_od_min <- 15; interval_sensor <- 15; no_sensor <- 650;
# PARAMETER TO BE REVISED
# Input: as input parameter
start <- start_hr*60*60 # 10AM (unit: sec)
end <- end_hr*60*60 # 11AM (unit: sec)
interval_od <- interval_od_min*60 # time interval: 15min -> 900sec
interval_sensor <-  interval_sensor_min*60  # time interval: 5min -> 900sec
no_sensor <-  no_sensor # To be defined
start_hr <- 7.5; end_hr <- 8.5 # Previously, start = 10; end = 11;
interval_od_min <- 15; interval_sensor_min <- 15; no_sensor <- 650;
# PARAMETER TO BE REVISED
# Input: as input parameter
start <- start_hr*60*60 # 10AM (unit: sec)
end <- end_hr*60*60 # 11AM (unit: sec)
interval_od <- interval_od_min*60 # time interval: 15min -> 900sec
interval_sensor <-  interval_sensor_min*60  # time interval: 5min -> 900sec
no_sensor <-  no_sensor # To be defined
start_hr <- 7.5; end_hr <- 8.5 # Previously, start = 10; end = 11;
interval_od_min <- 15; interval_sensor_min <- 15; no_sensor <- 650;
# PARAMETER TO BE REVISED
# Input: as input parameter
start <- start_hr*60*60 # 10AM (unit: sec)
end <- end_hr*60*60 # 11AM (unit: sec)
interval_od <- interval_od_min*60 # time interval: 15min -> 900sec
interval_sensor <-  interval_sensor_min*60  # time interval: 5min -> 900sec
no_sensor <-  no_sensor # To be defined
# Time interval
no_interval_od = (end-start)/interval_od; # Classify simulation time into each time interval
no_interval_sensor = (end-start)/interval_sensor;
setwd("/home/simon/Copy/SimMobility/Calibration Program/SimMob_ST_Calibration_SGE - Simon/data/WMATRIX")
ass <- read.table("assignment_matrix.csv", sep=" ") # Assignment matrix from SimMobility
head(ass)
colnames(ass) <- c('sensorID','sensor_time','agent_id','origin_id','destination_id', 'trip_start_time')
ass
head(ass)
odpair
datapath <- c('/home/simon/Copy/SimMobility/Calibration Program/SimMob_ST_Calibration_SGE - Simon/data/')
datapath
paste0(datapath, c("TripChain/baseFile.csv")
)
odpair <- fread(paste0(datapath, c("TripChain/Zonepair.csv")))
dim(odpair)
head(odpair)
odpair <- fread(paste0(datapath, c("TripChain/Zonepair.csv")))
head(odpair)
odpair[,2:3]
odpair
odpair[,1]
odpair[,2]
odpair[1,]
odpair
odpair <- subset(odpair, select=c('zone_o', 'zone_d'))
odpair
no_od = length(odpair[[1]])
no_od
t_od <- array(0, dim=no_interval_od);
t_od[1] = start;
for (i in 2:no_interval_od){
t_od[i] = t_od[i-1] + interval_od;
}
t_od
cat("Initializing sensors ..")
t_sensor <- array(0, dim=no_interval_sensor);
t_sensor[1] = start;
for (i in 2:no_interval_sensor){
t_sensor[i] = t_sensor[i-1] + interval_sensor;
}
c(no_sensor*no_interval_sensor, no_od*no_interval_od)
no_interval_sensor
no_sensor
no_od
no_interval_od
wmatrix = array(0, dim=c(no_sensor*no_interval_sensor, no_od*no_interval_od));
dim(wmatrix)
cat("Generating weight matrix ..")
length(ass[[1]])
head(ass)
j<-1
ass[[1]][j]
which(odpair[[1]] == ass[[4]][j] & odpair[[2]] == ass[[5]][j])
ass[[5]][j]
odpair[[2]]
sensor_index = ass[[1]][j]
od_index = which(odpair[[1]] == ass[[4]][j] & odpair[[2]] == ass[[5]][j])
time_index_sensor = which(ass[[2]][j]>=t_sensor & ass[[2]][j]<t_sensor+interval_sensor)
time_index_od = which(ass[[6]][j]>=t_od & ass[[6]][j]<t_od+interval_od)
time_index_od
time_index_sensor
od_index
row = sensor_index+no_sensor*(time_index_sensor-1)
col = od_index+no_od*(time_index_od-1)
row
col
cat("Post Processing ..")
odpair <- fread(paste0(datapath, c("WMATRIX/baseFile.csv")))
odpair <- subset(odpair, select=c('zone_o', 'zone_d'))
odpair <- fread(paste0(datapath, c("WMATRIX/baseFile.csv")))
odpair
odpair <- subset(odpair, select=c('V2', 'V3'))
odpair
no_od = length(odpair[[1]])
cat("Initializing ODs ..")
t_od <- array(0, dim=no_interval_od);
t_od[1] = start;
for (i in 2:no_interval_od){
t_od[i] = t_od[i-1] + interval_od;
}
cat("Initializing sensors ..")
t_sensor <- array(0, dim=no_interval_sensor);
t_sensor[1] = start;
for (i in 2:no_interval_sensor){
t_sensor[i] = t_sensor[i-1] + interval_sensor;
}
t_sensor
wmatrix = array(0, dim=c(no_sensor*no_interval_sensor, no_od*no_interval_od));
dim(wmatrix)
j<-1
sensor_index = ass[[1]][j]
sensor_index
od_index = which(odpair[[1]] == ass[[4]][j] & odpair[[2]] == ass[[5]][j])
od_index
time_index_sensor = which(ass[[2]][j]>=t_sensor & ass[[2]][j]<t_sensor+interval_sensor)
time_index_sensor
time_index_od = which(ass[[6]][j]>=t_od & ass[[6]][j]<t_od+interval_od)
time_index_od
row = sensor_index+no_sensor*(time_index_sensor-1)
row
col = od_index+no_od*(time_index_od-1)
col
wmatrix[row,col] = wmatrix[row,col]+1
wmatrix
wmatrix
a[2,2]
a <- array(0, dim=c(2,2))
a
for (j in 1:length(ass[[1]])){ # 1680892 j<-1
sensor_index = ass[[1]][j]
od_index = which(odpair[[1]] == ass[[4]][j] & odpair[[2]] == ass[[5]][j])
time_index_sensor = which(ass[[2]][j]>=t_sensor & ass[[2]][j]<t_sensor+interval_sensor)
time_index_od = which(ass[[6]][j]>=t_od & ass[[6]][j]<t_od+interval_od)
row = sensor_index+no_sensor*(time_index_sensor-1)
col = od_index+no_od*(time_index_od-1)
wmatrix[row,col] = wmatrix[row,col]+1 }
array(1:(no_od*no_interval_od)
, dim=c((no_od*no_interval_od),1));
no_od
no_interval_od
od_id
od_id=array(1:(no_od*no_interval_od), dim=c((no_od*no_interval_od),1));
result=cbind(od_id,wmatrix);
dim(wmatrix)
dim(od_id)
wmatrix=t(wmatrix);
od_id=array(1:(no_od*no_interval_od), dim=c((no_od*no_interval_od),1));
result=cbind(od_id,wmatrix);
head(result)
head(result[1:4, 1:4])
for (i in 1:nrow(wmatrix)){
if (sum(wmatrix[i,]) != 0) {wmatrix[i,]=wmatrix[i,]/sum(wmatrix[i,])}
}
od_id=array(1:(no_od*no_interval_od), dim=c((no_od*no_interval_od),1));
result=cbind(od_id,wmatrix);
result[1:10, 1:10]
result[1:10, 1:100]
